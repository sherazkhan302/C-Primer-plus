\documentclass[10 pt]{amsart}

\usepackage{amssymb,latexsym}
\usepackage{graphicx, setspace}

% For the cpart environment, although it would probably be better in the
% future to implement this with a list environment.
\newlength{\cgap}
\settowidth{\cgap}{\qquad \textbf{x. }}
\newlength{\cwidth}
\setlength{\cwidth}{\textwidth}
\addtolength{\cwidth}{-\cgap}
\newenvironment{cpart}[2][\cwidth]
	{\\ \phantom{\qquad}\textbf{#2. }\begin{minipage}[t]{#1}}
	{\end{minipage}}

\newcommand{\ttt}[1]{\texttt{#1}}
\newcommand{\ttb}[1]{\pmb{\texttt{#1}}}
% Macros, all must be filled out
\newcommand{\ChapNum}{10}

\begin{document}

	\title
	[Chapter \ChapNum]
	{C++ Primer Plus, 5$^\text{th}$ Edition \\
	Programming Exercises \\
	Chapter \ChapNum}

	\maketitle

	\begin{cpart}{1}
		Provide method definitions for the class described in 
		Review Question 5 and write a short program that illustrates
		all the features.
	\end{cpart}
	\vspace{2ex}

	\begin{cpart}{2}
		Here is a rather simple class definition:
		{\ttfamily
			\begin{tabbing}
				\phantom{\qquad}\=\hspace{5cm}\= \hspace{2 cm} \= \\
				class Person \{ \\
				private: \\
				\> 	static const int LIMIT = 25; \\
				\> 	string lname;  \> // Person's last name \\
				\> 	char fname[LIMIT];  \> // Person's first name \\
				public: \+ \\
				Person() \{lname = ""; fname[0] = '\textbackslash 0'; \} 
					// \#1 \\
				Person(const string \& ln, const char * fn = "Heyyou"); 
					// \#2 \\
				// the following methods display lname and fname \\
				void Show() const; \> // firstname lastname format \\
				void FormalShow() const; \> // lastname, firstname format
				\- \\
				\};
			\end{tabbing}
		}
		\phantom{\quad} \\
		Write a program that completes the implementation by providing
		code for the undefined methods.
		The program in which you use the class should also use the
		three possible constructor calls (no arguments, one argument, 
		and two arguments) and the two display methods.
		Here's an example that uses the constructors and methods:
		{\ttfamily
			\begin{tabbing}
				\hspace{6.25 cm}\= \\
				Person one; \> // use default constructor \\
				Person two("Smythecraft"); 
					\> // use \#2 with one default argument \\
				Person three("Dimwiddy", "Sam"); \> // use \#2, no defaults \\
				one.Show(); \\
				cout << endl; \\
				one.FormalShow(); \\
				// etc. for two and three
			\end{tabbing}
		}
	\end{cpart}
	\vspace{2ex}

	\begin{cpart}{3}
		Do Programming Exercise 1 from Chapter 9, but replace the 
		code shown there with an appropriate \ttt{golf} class 
		declaration.
		Replace \ttt{setgolf(golf \&, const char *, int)} with
		a constructor with the appropriate argument for providing
		initial values.
		Retain the interactive version of \ttt{setgolf}, but implement
		it by using the constructor. 
		(For example, for the code for \ttt{setgolf()}, obtain the
		data, pass the data to the constructor to create a temporary
		object, and assign the temporary object to the invoking object,
		which is \ttt{*this}.)
	\end{cpart}
	\vspace{2ex}

	\begin{cpart}{4}
		Do Programming Exercise 4 from Chapter 9, but convert the 
		\ttt{Sales} structure and its associated functions to a class
		and its methods.
		Replace the \ttt{setSales(Sales \&, double[], int)} function
		with a constructor. 
		Implement the interactive \ttt{setSales(Sales \&)} method
		by using the constructor.
		Keep the class within the namespace \ttt{SALES}.
	\end{cpart}
	\vspace{2ex}

	\begin{cpart}{5}
		Consider the following structore declaration: 
		{\ttfamily
			\begin{tabbing}
				\phantom{\qquad}\= \\
				struct customer \{ \\
				\> 	char fullname[35]; \\
				\> 	double payment; \\
				\};
			\end{tabbing}
		}
		\phantom{\quad} \\
		Write a program that adds and removes customer structures from
		a stack, represented by a \ttt{Stack} class declaration.
		Each time a customer is removed, his or her payment should
		be added to a running total, and the running total
		should be reported.
		Note: you should be able to use the \ttt{Stack} class
		unaltered; just change the \ttt{typedef} declaration so 
		that \ttt{Item} is type \ttt{customer} instead of 	
		\ttt{unsigned long}.
	\end{cpart}
	\vspace{2ex}

	\begin{cpart}{6}
		Here's a class declaration. 
		{\ttfamily
			\begin{tabbing}
				\phantom{\qquad}\=\hspace{8cm}\= \\
				class Move \\
				\{ \\
				private:
				\+ \\
					double x;
					double y;
				\- \\
				public:
				\+ \\
				Move(double a = 0, double b = 0); \> // sets x, y to a, b \\
				void showmove() const; \> // shows current x, y values \\
				Move add(const Move & m) const;
				\- \\
				// this function adds x of m to x of invoking object 
					to get new x, \\
				// adds y of m to y of invoking object to get new y, 
					creates a new \\
				// move object initialized to new x, y values and
					returns it \\
				\> 	void reset(double a = 0, double b = 0); 
					\> // resets x, y to a, b \\
				\};
			\end{tabbing}
		}
		\phantom{\quad} \\
		Create member function definitions and a program that 
		exercises the class.
	\end{cpart}
	\vspace{2ex}

	\begin{cpart}{7}
		A Betelguesean plorg has these properties:
		\begin{spacing}{1.5}
			Data \\
			\phantom{\hspace{6ex}} 
				A plorg has a name with no more than 19 letters.\\
			\phantom{\hspace{6ex}} 
			A plorg has a contentment index (CI), which is an integer \\
			Operations \\
			\phantom{\hspace{6ex}} 
				A new plorg starts out with a name and a CI of 50. \\
			\phantom{\hspace{6ex}} 
				A plorg's CI can change. \\
			\phantom{\hspace{6ex}} 
				A plorg can report its name and CI. \\
			\phantom{\hspace{6ex}} 
				The default plorg has the name "Plorga". [sic]
		\end{spacing}
		Write a \ttt{Plorg} class declaration (including data members
		and member function prototypes) that represents a plorg.
		Write the function definitions for the member functions.
		Write a short program that demonstrates all the features
		of the \ttt{Plorg} class.
	\end{cpart}
	\vspace{2ex}

	\begin{cpart}{8}
		You can describe a simple list as follows:
		\begin{itemize}
			\item 
				The simple list can hold zero or more items of some 
				particular type.
			\item
				You can create an empty list.
			\item 
				You can add items to the list.
			\item
				You can determine whether the list is empty.
			\item
				You can determine whether the list is full.
			\item
				You can visit each item in the list and perform some
				action on it.
		\end{itemize}
		As you can see, the list really is simple;
		it doesn't allow insertion or deletion, for example. \\[2ex]
		Design a \ttt{List} class to represent this abstract type.
		You should provide a \ttt{list.h} header file with 
		the class declaration and a \ttt{list.cpp} file with the 
		class method implementations.
		You should also create a short program that utilizes your
		design. \\[2ex]
		The main reason for keeping the list specification simple is to
		simplify this programming exercise.
		You can implement the list as an array, or, if you're familiar
		with the data type, as a linked list.
		But the public interface should not depend on your choice.
		That is, the public interface should not have array indices,
		pointers to nodes, and so on.
		It should be expressed in general concepts of creating a list, 
		adding an item to the list, and so on.
		The usual way to handle visiting each item and performing an 
		action is to use a function that takes a function pointer
		as an argument: \\[2ex]
		{\ttfamily
			void visit(void (*pf)(Item \&));
		} \\[2ex]
		Here \ttt{pf} points to a function (not a member function)
		that takes a reference to \ttt{Item} argument, where
		\ttt{Item} is the type for items in the list.
		The \ttt{visit()} function applies this function to each
		item in the list.
		You can use the \ttt{Stack} class as a general guide.
	\end{cpart}
	\vspace{2ex}

\end{document}

regarding tabbing environments:
\= (set tab)
\> (advance to next tab stop)
\<
\+ (indent; move margin right)
\- (unindent; move margin left)
\'
\`
\\ (end of line; newline)
\kill (ignore preceding text; use only for spacing)



		{\ttfamily
			\begin{tabbing}
				\phantom{\qquad}\=\phantom{\qquad}\=\phantom{\qquad}\= \\
		
			\end{tabbing}
		}











